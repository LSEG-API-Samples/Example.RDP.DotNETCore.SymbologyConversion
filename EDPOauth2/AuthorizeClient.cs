//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.14.0 (NJsonSchema v9.13.18.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

namespace Refinitiv.EDP.Example.AuthOauth2
{
    #pragma warning disable

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "12.0.14.0 (NJsonSchema v9.13.18.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class AuthorizeClient : IAuthorizeClient
    {
        private string _baseUrl = "https://api.refinitiv.com/auth/oauth2/beta1";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
    
        public AuthorizeClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient; 
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(() => 
            {
                var settings = new Newtonsoft.Json.JsonSerializerSettings();
                UpdateJsonSerializerSettings(settings);
                return settings;
            });
        }
    
        public string BaseUrl 
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }
    
        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
    
        /// <summary>Used to get a token for implicit grant.</summary>
        /// <param name="client_id">Your application's client id</param>
        /// <param name="response_type">Indicates the type of credentials expected in the response. Possible values include "token".</param>
        /// <param name="scope">The scope required by the application.</param>
        /// <param name="redirect_uri">A URI where the provider will redirect the ressource owner once he is properly identified.</param>
        /// <param name="state">Opaque value returned when the ressource owner is redirected back to the application.</param>
        /// <param name="cookie">A valid IPDP. This a temporary way to auth while the auth provider page does not exist.</param>
        /// <exception cref="EDPAuthorizeException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AuthorizeResponse> AuthorizeAsync(string client_id, string response_type, string scope, string redirect_uri, string state, string cookie)
        {
            return AuthorizeAsync(client_id, response_type, scope, redirect_uri, state, cookie, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Used to get a token for implicit grant.</summary>
        /// <param name="client_id">Your application's client id</param>
        /// <param name="response_type">Indicates the type of credentials expected in the response. Possible values include "token".</param>
        /// <param name="scope">The scope required by the application.</param>
        /// <param name="redirect_uri">A URI where the provider will redirect the ressource owner once he is properly identified.</param>
        /// <param name="state">Opaque value returned when the ressource owner is redirected back to the application.</param>
        /// <param name="cookie">A valid IPDP. This a temporary way to auth while the auth provider page does not exist.</param>
        /// <exception cref="EDPAuthorizeException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<AuthorizeResponse> AuthorizeAsync(string client_id, string response_type, string scope, string redirect_uri, string state, string cookie, System.Threading.CancellationToken cancellationToken)
        {
            if (client_id == null)
                throw new System.ArgumentNullException("client_id");
    
            if (response_type == null)
                throw new System.ArgumentNullException("response_type");
    
            if (scope == null)
                throw new System.ArgumentNullException("scope");
    
            if (state == null)
                throw new System.ArgumentNullException("state");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/authorize?");
            urlBuilder_.Append("client_id=").Append(System.Uri.EscapeDataString(ConvertToString(client_id, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("response_type=").Append(System.Uri.EscapeDataString(ConvertToString(response_type, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("scope=").Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (redirect_uri != null) 
            {
                urlBuilder_.Append("redirect_uri=").Append(System.Uri.EscapeDataString(ConvertToString(redirect_uri, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Append("state=").Append(System.Uri.EscapeDataString(ConvertToString(state, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (cookie != null)
                        request_.Headers.TryAddWithoutValidation("Cookie", ConvertToString(cookie, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "302") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new EDPAuthorizeException("OK, hold on while your user authenticates with us.", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(AuthError); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AuthError>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new EDPAuthorizeException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new EDPAuthorizeException<AuthError>("Authentication error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(AuthError); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AuthError>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new EDPAuthorizeException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new EDPAuthorizeException<AuthError>("Authentication error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(AuthError); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AuthError>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new EDPAuthorizeException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new EDPAuthorizeException<AuthError>("Authentication error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(AuthError); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AuthError>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new EDPAuthorizeException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new EDPAuthorizeException<AuthError>("Internal server error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "502") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(AuthError); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AuthError>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new EDPAuthorizeException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new EDPAuthorizeException<AuthError>("Upstream server error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "504") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(AuthError); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AuthError>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new EDPAuthorizeException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new EDPAuthorizeException<AuthError>("Upstream server error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new EDPAuthorizeException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
    
                        return new AuthorizeResponse((int)response_.StatusCode, headers_); 
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Used to revoke both types of token (access_token or revoke_token).</summary>
        /// <param name="token">The token that the client wants to get revoked.</param>
        /// <param name="token_type_hint">OPTIONAL.  A hint about the type of the token submitted for revocation.  Clients MAY pass this parameter in order to help the authorization server to optimize the token lookup.  If the server is unable to locate the token using the given hint, it MUST extend its search across all of its supported token types. The value can be access_token or refresh_token</param>
        /// <param name="client_id">OPTIONAL.  The client_id  = Application ID. Must be set here OR in the HTTP "Authorization" header as "basic" (see basicAuth definition here)</param>
        /// <param name="authorization">Basic auth with "client_id:client_secret" in base64.</param>
        /// <returns>[rfc7009#section-2.2](https://tools.ietf.org/html/rfc7009#section-2.2)' The authorization server responds with HTTP status code 200 if the token has been revoked successfully or if the client submitted an invalid token.</returns>
        /// <exception cref="EDPAuthorizeException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AuthorizeResponse> RevokeAsync(string token, string token_type_hint, string client_id, string authorization)
        {
            return RevokeAsync(token, token_type_hint, client_id, authorization, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Used to revoke both types of token (access_token or revoke_token).</summary>
        /// <param name="token">The token that the client wants to get revoked.</param>
        /// <param name="token_type_hint">OPTIONAL.  A hint about the type of the token submitted for revocation.  Clients MAY pass this parameter in order to help the authorization server to optimize the token lookup.  If the server is unable to locate the token using the given hint, it MUST extend its search across all of its supported token types. The value can be access_token or refresh_token</param>
        /// <param name="client_id">OPTIONAL.  The client_id  = Application ID. Must be set here OR in the HTTP "Authorization" header as "basic" (see basicAuth definition here)</param>
        /// <param name="authorization">Basic auth with "client_id:client_secret" in base64.</param>
        /// <returns>[rfc7009#section-2.2](https://tools.ietf.org/html/rfc7009#section-2.2)' The authorization server responds with HTTP status code 200 if the token has been revoked successfully or if the client submitted an invalid token.</returns>
        /// <exception cref="EDPAuthorizeException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<AuthorizeResponse> RevokeAsync(string token, string token_type_hint, string client_id, string authorization, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/revoke");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (authorization != null)
                        request_.Headers.TryAddWithoutValidation("Authorization", ConvertToString(authorization, System.Globalization.CultureInfo.InvariantCulture));
                    var keyValues_ = new System.Collections.Generic.List<System.Collections.Generic.KeyValuePair<string, string>>();
                    if (token == null)
                        throw new System.ArgumentNullException("token");
                    else
                        keyValues_.Add(new System.Collections.Generic.KeyValuePair<string, string>("token", ConvertToString(token, System.Globalization.CultureInfo.InvariantCulture)));
                    if (token_type_hint != null)
                        keyValues_.Add(new System.Collections.Generic.KeyValuePair<string, string>("token_type_hint", ConvertToString(token_type_hint, System.Globalization.CultureInfo.InvariantCulture)));
                    if (client_id != null)
                        keyValues_.Add(new System.Collections.Generic.KeyValuePair<string, string>("client_id", ConvertToString(client_id, System.Globalization.CultureInfo.InvariantCulture)));
                    request_.Content = new System.Net.Http.FormUrlEncodedContent(keyValues_);
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            return new AuthorizeResponse((int)response_.StatusCode, headers_);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(AuthError); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AuthError>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new EDPAuthorizeException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new EDPAuthorizeException<AuthError>("Internal server error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new EDPAuthorizeException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
    
                        return new AuthorizeResponse((int)response_.StatusCode, headers_); 
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Used to get a token for password grant.</summary>
        /// <param name="grant_type">Supported values "password" and "refresh_token"</param>
        /// <param name="username">The resource owner username (typically email).</param>
        /// <param name="password">The resource owner password.</param>
        /// <param name="scope">The scope of the access request.</param>
        /// <param name="refresh_token">The refresh token issued to the client.</param>
        /// <param name="client_id">The client_id  = Application ID. Alternatively, can be provided in Authorization header.</param>
        /// <param name="authorization">"Basic" + base64 encoded "client_id:client_secret", where client_id=Application ID and client_secret is empty</param>
        /// <param name="takeExclusiveSignOnControl">OPTIONAL. This is a Boolean that will allow the API Caller to create session if the nb of concurrent session have been reached (of course, by doing this a valid session will be killed) - default = false</param>
        /// <param name="multiFactorAuthenticationCode">OPTIONAL. This a string that will have to be send only if MFA is required to authenticate the identity. This code will be send by SMS or Email (depending on how MFA has been setup). - default = null</param>
        /// <param name="newPassword">OPTIONAL. This is a string that will have to be send if a new Password
        ///  is required to authenticate. (Note: the current and new passwords
        ///  will be required in order to authenticate) - default = null</param>
        /// <returns>OK</returns>
        /// <exception cref="EDPAuthorizeException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AuthorizeResponse<Tokenresponse>> TokenAsync(string grant_type, string username, string password, string deviceId, string scope, string refresh_token, string client_id, string authorization, string takeExclusiveSignOnControl, string multiFactorAuthenticationCode, string newPassword)
        {
            return TokenAsync(grant_type, username, password, deviceId, scope, refresh_token, client_id, authorization, takeExclusiveSignOnControl, multiFactorAuthenticationCode, newPassword, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Used to get a token for password grant.</summary>
        /// <param name="grant_type">Supported values "password" and "refresh_token"</param>
        /// <param name="username">The resource owner username (typically email).</param>
        /// <param name="password">The resource owner password.</param>
        /// <param name="scope">The scope of the access request.</param>
        /// <param name="refresh_token">The refresh token issued to the client.</param>
        /// <param name="client_id">The client_id  = Application ID. Alternatively, can be provided in Authorization header.</param>
        /// <param name="authorization">"Basic" + base64 encoded "client_id:client_secret", where client_id=Application ID and client_secret is empty</param>
        /// <param name="takeExclusiveSignOnControl">OPTIONAL. This is a Boolean that will allow the API Caller to create session if the nb of concurrent session have been reached (of course, by doing this a valid session will be killed) - default = false</param>
        /// <param name="multiFactorAuthenticationCode">OPTIONAL. This a string that will have to be send only if MFA is required to authenticate the identity. This code will be send by SMS or Email (depending on how MFA has been setup). - default = null</param>
        /// <param name="newPassword">OPTIONAL. This is a string that will have to be send if a new Password
        ///  is required to authenticate. (Note: the current and new passwords
        ///  will be required in order to authenticate) - default = null</param>
        /// <returns>OK</returns>
        /// <exception cref="EDPAuthorizeException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<AuthorizeResponse<Tokenresponse>> TokenAsync(string grant_type, string username, string password, string deviceId, string scope, string refresh_token, string client_id, string authorization, string takeExclusiveSignOnControl, string multiFactorAuthenticationCode, string newPassword, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/token");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (authorization != null)
                        request_.Headers.TryAddWithoutValidation("Authorization", ConvertToString(authorization, System.Globalization.CultureInfo.InvariantCulture));
                    var keyValues_ = new System.Collections.Generic.List<System.Collections.Generic.KeyValuePair<string, string>>();
                    if (grant_type == null)
                        throw new System.ArgumentNullException("grant_type");
                    else
                        keyValues_.Add(new System.Collections.Generic.KeyValuePair<string, string>("grant_type", ConvertToString(grant_type, System.Globalization.CultureInfo.InvariantCulture)));
                    if (username == null)
                        throw new System.ArgumentNullException("username");
                    else
                        keyValues_.Add(new System.Collections.Generic.KeyValuePair<string, string>("username", ConvertToString(username, System.Globalization.CultureInfo.InvariantCulture)));
                    if (password != null)
                        keyValues_.Add(new System.Collections.Generic.KeyValuePair<string, string>("password", ConvertToString(password, System.Globalization.CultureInfo.InvariantCulture)));
                    if (deviceId != null)
                        keyValues_.Add(new System.Collections.Generic.KeyValuePair<string, string>("deviceId", ConvertToString(deviceId, System.Globalization.CultureInfo.InvariantCulture)));
                    if (scope != null)
                        keyValues_.Add(new System.Collections.Generic.KeyValuePair<string, string>("scope", ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture)));
                    if (refresh_token != null)
                        keyValues_.Add(new System.Collections.Generic.KeyValuePair<string, string>("refresh_token", ConvertToString(refresh_token, System.Globalization.CultureInfo.InvariantCulture)));
                    if (client_id != null)
                        keyValues_.Add(new System.Collections.Generic.KeyValuePair<string, string>("client_id", ConvertToString(client_id, System.Globalization.CultureInfo.InvariantCulture)));
                    if (takeExclusiveSignOnControl != null)
                        keyValues_.Add(new System.Collections.Generic.KeyValuePair<string, string>("takeExclusiveSignOnControl", ConvertToString(takeExclusiveSignOnControl, System.Globalization.CultureInfo.InvariantCulture)));
                    if (multiFactorAuthenticationCode != null)
                        keyValues_.Add(new System.Collections.Generic.KeyValuePair<string, string>("multiFactorAuthenticationCode", ConvertToString(multiFactorAuthenticationCode, System.Globalization.CultureInfo.InvariantCulture)));
                    if (newPassword != null)
                        keyValues_.Add(new System.Collections.Generic.KeyValuePair<string, string>("newPassword", ConvertToString(newPassword, System.Globalization.CultureInfo.InvariantCulture)));
                    request_.Content = new System.Net.Http.FormUrlEncodedContent(keyValues_);
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(Tokenresponse); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<Tokenresponse>(responseData_, _settings.Value);
                                return new AuthorizeResponse<Tokenresponse>((int)response_.StatusCode, headers_, result_); 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new EDPAuthorizeException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(AuthError); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AuthError>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new EDPAuthorizeException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new EDPAuthorizeException<AuthError>("Authentication error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(AuthError); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AuthError>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new EDPAuthorizeException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new EDPAuthorizeException<AuthError>("Authentication error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(AuthError); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AuthError>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new EDPAuthorizeException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new EDPAuthorizeException<AuthError>("Authentication error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(AuthError); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AuthError>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new EDPAuthorizeException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new EDPAuthorizeException<AuthError>("Internal server error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "502") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(AuthError); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AuthError>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new EDPAuthorizeException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new EDPAuthorizeException<AuthError>("Upstream server error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "504") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(AuthError); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<AuthError>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new EDPAuthorizeException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new EDPAuthorizeException<AuthError>("Upstream server error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new EDPAuthorizeException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return new AuthorizeResponse<Tokenresponse>((int)response_.StatusCode, headers_, default(Tokenresponse)); 
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value;
                        }
                    }
                }
            }
            else if (value is bool) {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            return System.Convert.ToString(value, cultureInfo);
        }
    }


    [System.CodeDom.Compiler.GeneratedCode("NSwag", "12.0.14.0 (NJsonSchema v9.13.18.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class EDPAuthorizeException<TResult> : EDPAuthorizeException
    {
        public TResult Result { get; private set; }

        public EDPAuthorizeException(string message, int statusCode, string response, System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException) 
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

    #pragma warning restore
}